**在阿里的编码规范中约束的分层如下图**
<a href="https://ibb.co/zZTMn0x"><img src="https://i.ibb.co/Wf4hxY5/image.png" alt="image" border="0"></a>

# 代码优化分层
<a href="https://ibb.co/vB8JPmv"><img src="https://i.ibb.co/fS7CptG/1-2.png" alt="1-2" border="0"></a>

# 1. 代码如何按照阿里的编码规范中的约束进行分层
  * 1 开放接口层规范：      可直接封装 Service 方法暴露成 RPC 接口;通过 Web 封装成 http 接口;**进行网关安全控制、流量控制**等，就是说开放接口层有两种接口接入： **1 RPC 接口  2 HTTP接口**
      开放接口层代码实现：  最上层 Controller 和 TService 是我们阿里分层规范里面的第一层：**轻业务逻辑，参数校验，异常兜底**，通常这种接口可以轻易更换接口类型，所以业务逻辑必须要轻，甚至不做
                          具体逻辑，如果我们把业务编排放在 Controller 层去做的话，如果以后我们要接入RPC框架 Thrift，我们这里又需要把业务编排在做一次，这样会导致我们每接入一个入口层，这个
                          业务编排代码都得重新复制一份，这样大量的重复工作必定会导致我们开发效率下降，所以我们需要把**业务编排逻辑都得放进 Service 中去做**
  
  * 2 终端显示层规范：各个端的模板渲染并执行显示的层。当前主要是 velocity 渲染，JS 渲染，JSP 渲染，移动端展示等
  
  * 3 Web 层规范：主要是对访问控制进行转发，各类基本参数校验，或者不复用的业务简单处理等
  
  * 4 Service 层规范：相对具体的业务逻辑服务层，业务层，复用性较低，这里推荐每一个 Controller 方法都得对应一个 Service
  
  * 5 Manager 层规范：通用业务处理层---对第三方平台封装的层，预处理返回结果及转化异常信息，对 Service 层通用能力的下沉，如缓存方案、中间件通用处理。与 DAO 层交互，对多个 DAO 的组合复用
                                     可复用逻辑层。这里的 Mannager 可以是单个服务的，比如我们的 Cache，MQ 等等，当然也可以是复合的。当你需要调用多个 Mannager 的时候，这个可以合为一个
                                     Mannager，比如逻辑上的连表查询等。如果是 httpMannager 或 rpcMannager 需要在这一层做一些数据转换              
  
  * 6 DAO 层规范：     数据访问层，与底层 MySQL、Oracle、Hbase 进行数据交互
      DAO 层代码实现： 数据库访问层。主要负责“操作数据库的某张表，映射到某个 Java 对象”，DAO 应该只允许自己的 Service 访问，其他 Service 要访问我的数据必须通过对应的 Service

  * 代码中分层领域模型的转换
    
    分层领域模型的转换：  在阿里巴巴编码规约中列举了下面几个领域模型规约：

        DO(Data Object)：与数据库表结构一一对应，通过 DAO 层向上传输数据源对象。
        DTO(Data Transfer Object)：数据传输对象，Service 或 Manager 向外传输的对象。
        BO(Business Object)：业务对象。由 Service 层输出的封装业务逻辑的对象。
        AO(Application Object)：应用对象。在 Web 层与 Service 层之间抽象的复用对象模型，极为贴近展示层，复用度不高。
        VO(View Object)：显示层对象，通常是 Web 向模板渲染引擎层传输的对象。
        Query：数据查询对象，各层接收上层的查询请求。注意超过2个参数的查询封装，禁止使用 Map 类来传输。

     <a href="https://ibb.co/0t9kQwn"><img src="https://i.ibb.co/DpMNLq1/174047f36cd0980283ba76c8804c53c1.png" alt="174047f36cd0980283ba76c8804c53c1" border="0"></a>
    
    阿里终面：优秀的代码都是如何分层的？
说起应用分层，大部分人都会认为这个不是很简单嘛，就 Controller，Service，Mapper 三层。

作者：咖啡拿铁来源：咖啡拿铁|2021-03-24 09:23 收藏  分享
说起应用分层，大部分人都会认为这个不是很简单嘛，就 Controller，Service，Mapper 三层。



图片来自 Pexels

看起来简单，很多人其实并没有把他们职责划分开，在很多代码中，Controller 做的逻辑比 Service 还多，Service 往往当成透传了，这其实是很多人开发代码都没有注意到的地方，反正功能也能用，至于放哪无所谓呗。

这样往往造成后面代码无法复用，层级关系混乱，对后续代码的维护非常麻烦。

的确在这些人眼中分层只是一个形式，前辈们的代码这么写的，其他项目代码这么写的，那么我也这么跟着写。

但是在真正的团队开发中每个人的习惯都不同，写出来的代码必然带着自己的标签，有的人习惯 Controller 写大量的业务逻辑，有的人习惯在 Service 中之间调用远程服务。

这样就导致了每个人的开发代码风格完全不同，后续其他人修改的时候，一看，我靠这个人写的代码和我平常的习惯完全不同，修改的时候到底是按着自己以前的习惯改，还是跟着前辈们走。

这又是个艰难的选择，选择一旦有偏差，你的后辈又维护你的代码的时候，恐怕就要骂人了。

所以一个好的应用分层需要具备以下几点：

方便后续代码进行维护扩展
分层的效果需要让整个团队都接受
各个层职责边界清晰
如何进行分层
阿里规范
在阿里的编码规范中约束的分层如下图：



①开放接口层：可直接封装 Service 方法暴露成 RPC 接口;通过 Web 封装成 http 接口;进行网关安全控制、流量控制等。

②终端显示层：各个端的模板渲染并执行显示的层。当前主要是 velocity 渲染，JS 渲染，JSP 渲染，移动端展示等。

③Web 层：主要是对访问控制进行转发，各类基本参数校验，或者不复用的业务简单处理等。

④Service 层：相对具体的业务逻辑服务层。

⑤Manager 层：通用业务处理层。

它有如下特征:

对第三方平台封装的层，预处理返回结果及转化异常信息。
对 Service 层通用能力的下沉，如缓存方案、中间件通用处理。
与 DAO 层交互，对多个 DAO 的组合复用。
⑥DAO 层：数据访问层，与底层 MySQL、Oracle、Hbase 进行数据交互。

阿里巴巴规约中的分层比较清晰简单明了，但是描述得还是过于简单了，以及 Service 层和 Manager 层有很多同学还是有点分不清楚之间的关系，就导致了很多项目中根本没有 Manager 层的存在。

下面介绍一下具体业务中应该如何实现分层。

优化分层
从我们的业务开发中总结了一个较为的理想模型,这里要先说明一下由于我们的 RPC 框架选用的是 Thrift 可能会比其他的一些 RPC 框架例如 Dubbo 会多出一层，作用和 controller 层类似。



最上层 Controller 和 TService 是我们阿里分层规范里面的第一层：轻业务逻辑，参数校验，异常兜底。

通常这种接口可以轻易更换接口类型，所以业务逻辑必须要轻，甚至不做具体逻辑。

①Service：业务层，复用性较低，这里推荐每一个 Controller 方法都得对应一个 Service，不要把业务编排放在 Controller 中去做，为什么呢?

如果我们把业务编排放在 Controller 层去做的话，如果以后我们要接入 Thrift，我们这里又需要把业务编排在做一次，这样会导致我们每接入一个入口层这个代码都得重新复制一份。

如下图所示：



这样大量的重复工作必定会导致我们开发效率下降，所以我们需要把业务编排逻辑都得放进 Service 中去做：



②Mannager：可复用逻辑层。这里的 Mannager 可以是单个服务的，比如我们的 Cache，MQ 等等，当然也可以是复合的。

当你需要调用多个 Mannager 的时候，这个可以合为一个 Mannager，比如逻辑上的连表查询等。如果是 httpMannager 或 rpcMannager 需要在这一层做一些数据转换。

③DAO：数据库访问层。主要负责“操作数据库的某张表，映射到某个 Java 对象”，DAO 应该只允许自己的 Service 访问，其他 Service 要访问我的数据必须通过对应的 Service。

分层领域模型的转换
在阿里巴巴编码规约中列举了下面几个领域模型规约：

DO(Data Object)：与数据库表结构一一对应，通过 DAO 层向上传输数据源对象。
DTO(Data Transfer Object)：数据传输对象，Service 或 Manager 向外传输的对象。
BO(Business Object)：业务对象。由 Service 层输出的封装业务逻辑的对象。
AO(Application Object)：应用对象。在 Web 层与 Service 层之间抽象的复用对象模型，极为贴近展示层，复用度不高。
VO(View Object)：显示层对象，通常是 Web 向模板渲染引擎层传输的对象。
Query：数据查询对象，各层接收上层的查询请求。注意超过2个参数的查询封装，禁止使用 Map 类来传输。


每一个层基本都自己对应的领域模型，这样就导致了有些人过于追求每一层都是用自己的领域模型。

这样就导致了一个对象可能会出现 3 次甚至 4 次转换在一次请求中，当返回的时候同样也会出现 3-4 次转换，这样有可能一次完整的请求-返回会出现很多次对象转换。

如果在开发中真的按照这么来，恐怕就别写其他的了，一天就光写这个重复无用的逻辑算了吧。

所以我们得采取一个折中的方案：

允许 Service/Manager 可以操作数据领域模型，对于这个层级来说，本来自己做的工作也是做的是业务逻辑处理和数据组装。
Controller/TService 层的领域模型不允许传入 DAO 层，这样就不符合职责划分了。
同理，不允许 DAO 层的数据传入到 Controller/TService
    
    
    <a href="https://ibb.co/NSXBMgD"><img src="https://i.ibb.co/74HmqxM/2.png" alt="2" border="0"></a>


# 2. 分层架构的风格
  * 大型机架构风格（Mainframe）
  * [原始分布式架构风格（Distributed）](https://icyfenix.cn/architecture/architect-history/primitive-distribution.html)
  * [Spring Boot 实现单体架构（Monolithic）](https://icyfenix.cn/architecture/architect-history/monolithic.html)
  * [Spring Cloud 实现微服务架构](https://icyfenix.cn/exploration/projects/microservice_arch_springcloud.html)
  * [Kubernetes 为基础设施的微服务架构](https://icyfenix.cn/exploration/projects/microservice_arch_kubernetes.html)
  * 后微服务架构风格：云原生时代（Cloud Native）
    * [后微服务时代: Istio 为基础设施的服务网格架构（Service Mesh）](https://icyfenix.cn/exploration/projects/servicemesh_arch_istio.html)
  * [AWS Lambda 为基础的无服务架构（Serverless）](https://icyfenix.cn/exploration/projects/serverless_arch.html)
  * CQRS模式架构
    * [SpringBoot+CQRS微服务设计模式教程](https://www.jdon.com/55380) 






# 用用的参考

* [优秀的代码都是如何分层的](https://developer.51cto.com/art/202103/652080.htm)
