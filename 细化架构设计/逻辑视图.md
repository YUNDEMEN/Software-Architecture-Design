**逻辑架构 = 模块划分 + 接口定义 + 领域模型**

关注不同粒度的职责划分(逻辑层，功能子模块，模块，关键类)和接口定义，分别封装到专门模块，通用模块中。逻辑架构设计思维融合的关键是把**层 功能模块 细粒度模块**这三个概念看清想透。

UML描述逻辑架构：   静态描述： 包图  类图  对象图

                   动态描述： 序列图 协作图 状态图 活动图
                   
* 逻辑架构设计到什麽粒度？
    
  一般是设计到模块一级
  
* 功能子系统是否就是总体架构？

  <a href="https://ibb.co/HpDw63d"><img src="https://i.ibb.co/mFCZkg8/2.png" alt="2" border="0"></a>
    
  不是， 在设计架构时，最常见的就是划分完功能子系统就完事了，总体架构设计就是将一个综合系统切分成多个 “顶级子系统”，每个“顶级子系统”都是可交付的实体
  具体而言，总体架构设计要明确把系统切分成后端系统， 前端系统，中间件系统，存储系统，底层系统等这些“顶级子系统”，而且还要把在开发中用到的哪些API，哪些程序库，哪些前端插件，哪些后端驱动程序等也作为特殊的顶级子系统明确出来。

  **顶级子系统划分： 切分的就是解决方案空间。**


* 逻辑架构设计核心任务

  * 1  模块划分设计方法
  
       决策有两种不同的方法： 借助经验和推理分析, **根据功能树切分功能模块和分解上下文图进行分层，偏重经验，用例驱动的设计方法，偏重分析。**
       
  
       模块划分是架构师的基本职责，常用的4种方法
      
       * 第1种方法 功能树---从需求层面的“功能树”，到设计层面粗粒度(功能相近的一组用例一般被划分到了同一个“功能模块”)的功能划分。
       
       功能树架构设计的优缺点：
       
       优点：
       
       缺点：设计不到位，功能模块（就是子系统）太粗粒度，缺乏对于模块间交互关系的定义，因此不利于模块复用，一个功能应该由不同模块的协作完成，只有这
             样才有利于模块重用。
       

       **功能树和功能模块结构图的不同点：**
      
         功能树是需求分析的成果，是一种功能分解结构，将功能大类 功能组 功能项的关系以树的形式呈现出来。 功能模块结构图是对系统进行分解的结果示意图
         
         功能树刻画的是现实问题领域，功能模块结构图刻画的是解决方案
         
         功能树属于需求分析层面，功能模块结构图属于设计层面
         
         功能树是从需求分析得到的，功能模块结构图是亲自设计出来的。
      
       **模块划分设计方法核心原理**
     
          从需求分析的功能组到细化架构设计功能模块，是粗粒度功能模块划分的常见手段。      
      
       **模块划分设计方法步骤**
      
          第一步： 获得功能树
      
              1. 软件需求规格说明书
              
              2. 方案建议书
              
              3. 愿景文档
              
         第二步： 评审功能树
      
              要分辩真假功能树，**真功能树是上级节点是功能组，下级节点是细分功能**
              
         第三步： 粗粒度功能模块的划分
      
              对于功能树上的业务上紧密相关的一组功能在实现上也常会涉及相同的函数，类，数据结构等，因此将这组功能映射到功能模块，有利于设计的高聚合，松耦合，
      
              另一方面，一些公共服务会用于同时支持多组功能的实现，将这些公共服务分别放入相应的通用模块中
      
       * 第2种方法 分层架构---如何分层，如何分别封装各种“外部交互”，促进模块分解
         
       **经典模式： 四层架构 UI层 + SI层 + PD层 + DM层 （三层架构只是四层架构的特例）**
         
               UI层(User Interface): 负责封装与用户的双向交互
                   
               PD层(Problem Domain): 负责问题领域或业务领域的功能实现
                   
               SI层(System Interaction):负责封装外部系统的交互，负责封装底层硬件的具体交互方式
                   
               DI层(Data Management): 负责封装各种持久化数据的具体管理方式。
         
       **分层架构的设计思想**
         
              无论四层架构或三层架构，都包含着“封装外部交互”的设计思想。
              
              外部用户-----通过“UI交互层”封装与其的交互
            
              外部系统-----通过“系统交互层”封装与其的交互
         
              底层系统-----通过“系统交互层”封装与其的交互       
              
              文件系统或数据库系统-----通过“数据管理层”封装与其的交互              
         
             业务层或PD层，就不需要知道以上的交互细节，可以更关心业务领域本身的逻辑
         
       **分层架构设计的步骤**
             
             从需求分析中的“上下文图”过渡到“分层架构的设计”，直接了当地把“系统和外部的关系”刻画清楚。
             
             分层架构设计的优缺点：
             
             优点：
             
             缺点：没有划分出细粒度模块。
             
             
            上下文图---把系统外部的4种事物都识别到位，
              
                    1） 外部用户
                    
                    2） 文件或数据库等持久化存储设施
                    
                    3） 外部系统与底层硬件
                    
                    4） 时限触发机制
                    
            分层架构的设计---通过上下文图，把待开发软件系统中要封装的硬件 要控制 交互的系统都识别出来，然后设计相应的分层架构并决定每一层的职责。
            
                    UI交互层是否存在
                    
                    UI交互层的职责包含哪几部分
                    
                    系统交互层是否存在
                    
                    系统交互层的职责包含哪几部分
                    
                    数据管理层是否存在
                    
                    数据管理层的职责包含哪几部分  
                    
                    问题领域层的职责包含哪几部分 
                    
         
       * 第3种方法 用例驱动---从用例（需求）到模块划分结构的具体步骤，现代的用例驱动的模块划分过程
       
       **用例驱动架构设计的核心思想： 从用例到类 再到模块划分的关键思路. 从“内外对话”到“内部协作”，打破黑盒，设计内部，就是从用例到设计过渡的关键**
       内外对话---描述的是需求的序列图
       
       内部协作---描述的是设计的序列图
       
       关注《用例规约》的事件流说明，理清序列图和需求之间的“关系”，能打通需求到设计的转换环节，离设计的成功不远了。
       
       
       **从需求层的用例到设计层系统的模块结构的 两环节 四步骤**
       
            需求分析环节
              
               一方面用例图定义系统能提供给外部Actor的功能，此步在先
               
               另一方面，用例规约（用例图可不够）进一不将笼统的功能明确定义为能够为用户带来价值的交互序列，但仍保持系统作为黑盒，此步在后
            
            架构设计环节
            
               第一步 一方面， 打破黑盒，识别一个用例背后有哪些类，以及设计类之间的交互，此步在先--运用鲁棒图 设计序列图
               
                   技术点 1： 运用鲁棒图，一步步发现用例背后需要哪些类
               
                   技术点 2： 运用设计序列图，明确类之间的交互关系
                   
                   技术点 3： 如何从众多用例中确定少数对架构设计关键的用例，对于大系统，用例非常多，是否要研究每个用例实现？
                   
                          用例驱动的设计，主要输入的是一组用例，不是一个用例，也不是全部用例，要从众多用例中确定少数对架构设计关键的用例
               
               第二步 另一方面，梳理通过多个用例识别出的这些类，并将它们划分到不同模块，此步在后---运用包图
               
                    这一步是用例驱动思想的精髓，是有别于别的(功能模块划分 架构分层)“自顶向下”设计方法的最大不同，用例驱动包含了“自底向上”的设计
                    思想，所以可以兼收结合使用。
               
               
         
       * 第4种方法 模块化---细粒度模块化时，怎样综合利用多种模块划分的手段技巧，通用模块和通用机制的识别
       
                           
    
    
  * 2  接口定义设计方法
  
     **正确的设计思路是 “协作决定接口” ，有考虑这个软件单元要和其他哪些单元协作，可使用 “序列图”辅助进行设计**
  
  * 3  领域模型细化
       * 1. 接口定义类
       * 2. Facade实现类
       * 3. 核心控制类
       * 4. 对系统可展性有根本影响的领域模型的那些类

       领域建模产生领域模型，领域模型在“细化架构设计”时又要进一步进行“领域模型细化”，  

       领域模型细化是有必要的， 因为前期的领域模型不是面向实现的，到了领域模型细化时，模型调整和改变在所难免，有两点要注意
    
         1. 必需明确区分**类和接口**，进一步将领域模型设计到可以编程实现的程度。
    
         2. 细化架构环节，把**前期的类降格成属性，或把前期的属性升格成类**

      
    
  
  
  
